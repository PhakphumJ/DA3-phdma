---
title: "Assignment 2 - AirBnB"
author: "Phakphum Jatupitpornchan"
format: html
editor: visual
---

```{r}
#| echo: false
#| warning: false

rm(list=ls())

library(readr)
library(dplyr)
library(ggplot2)
library(weights)
library(caret)
library(kableExtra)
library(tidyr)
library(fastDummies)
library(data.table)

# Set Working Directory and Importing Data

setwd("D:/Onedrive-CEU/OneDrive - Central European University/CEU/Prediction with Machine Learning/Assignment/DA3-phdma/Assignment 2")

Data_Mar <- read_csv("listings_mar_2023.csv", show_col_types = FALSE, na = c("", "NA", "N/A"))
Data_Sept <- read_csv("listings_sept_2023.csv", show_col_types = FALSE, na = c("", "NA", "N/A"))
```

## Defining Live Data and Sample

Live data: Observations with *property_type*%in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment") & *accommodates* \>= 2 & *accommodates* \<= 6

Sample: Observations with *property_type* %in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment", "Entire home/apt", "Entire condo", "Private room in condo", "Shared room in condo") & *accommodates* \>= 2 & *accommodates* \<= 6.

The definition of sample here (apartments and condos) is wider than the definition of target observations (apartments) to increase the sample size.

I split the sample into 2 main parts.

1.  Hold-out set: 15% of apartments randomly selected to be in the hold-out set. I only use apartments because the results on performance in this case would then be closer to the results from actual live data which only contains apartments.
2.  Work set: The remaining 85% of the sample is the work set. It is split further to be training set and test set.

```{r}
#| echo: false

### Filtering data
Data_Mar = Data_Mar %>% 
  filter(property_type %in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment", "Entire home/apt", "Entire condo", "Private room in condo", "Shared room in condo"), accommodates >= 2, accommodates <= 6)


Data_Sept = Data_Sept %>% 
  filter(property_type %in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment", "Entire home/apt", "Entire condo", "Private room in condo", "Shared room in condo"), accommodates >= 2, accommodates <= 6)


```


```{r}
### Split sample into hold-out and work set.
set.seed(20231126)

## hold-out set will only consists of apartments. Split 20% of apartments into hold-out set.
hold_out_Mar <- Data_Mar %>%
  filter(property_type %in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment")) %>%
  sample_frac(0.20)

hold_out_Sept <- Data_Sept %>%
  filter(property_type %in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment")) %>%
  sample_frac(0.20)

## Subtract hold-out set from the sample to get work set.
Data_Mar <- Data_Mar %>%
  filter(!id %in% hold_out_Mar$id)

Data_Sept <- Data_Sept %>% 
  filter(!id %in% hold_out_Sept$id)

```

## Features Engineering

### Picking features

-   Information about host

    -   Host response time (*host_response_time*)

    -   Host response rate (*host_response_rate*)

    -   Host acceptance rate (*host_acceptance_rate*)

    -   Is superhost (*host_is_superhost*)

    -   Total listings (*host_total_listings_count*)

    -   Has identity identified (*host_identity_verified*)

-   Information about the accomodation

    -   Neighbourhood (*neighbourhood_cleansed*)

    -   Types of property (*property_type*)

    -   Types of room (*room_type*)

    -   Number of people that can be accommodated (*accommodates*)

    -   Types and number of bathrooms (*bathrooms_text*)

    -   Amenities (*amenities*)

    -   Minimum number of night stay for the listing (*minimum_nights*)

    -   Maximum number of night stay for the listing (*maximum_nights*)

    -   Is availability (*has_availability*)

    -   The availability of the listing 30 days in the future as determined by the calendar (*availability_30*)

    -   The availability of the listing 60 days in the future as determined by the calendar (*availability_60*)

    -   The availability of the listing 90 days in the future as determined by the calendar (*availability_90*)

    -   The availability of the listing 365 days in the future as determined by the calendar (*availability_365*)

    -   The number of reviews the listing has (*number_of_reviews*)

    -   The number of reviews the listing has (in the last 12 months) (*number_of_reviews_ltm*)

    -   The date of the last/newest review (*last_review*)

    -   Overall review rating (review_scores_rating)

    -   Average accuracy review rating (*review_scores_accuracy*)

    -   Average cleanliness review rating (*review_scores_cleanliness*)

    -   Average check-in review rating (*review_scores_checkin*)

    -   Average communication review rating (*review_scores_communication*)

    -   Average location review rating (*review_scores_location*)

    -   Average value review rating (*review_scores_value*)

    -   Whether the guest can automatically book the listing without the host requiring to accept their booking request. (*instant_bookable*)

    -   Description of the accommodation (*description*)

    -   Description of the neighborhood (*neighborhood_overview*)

        -   BTS, bts, Skytrain, skytrain, MRT, mrt, Metro, metro, Subway, subway, Airport Rail Link, Airport Link, airport rail link, airport link, ARL, arl

-   Only use the most relevant amenities, otherwise takes too long.

    -   Hair dryer

    -   Shampoo

    -   Shower gel

    -   Air conditioning

    -   Essentials

    -   Wifi

    -   Washer

    -   Iron

    -   Smoking allowed

    -   Free parking on premises

    -   Luggage dropoff allowed

    -   Kitchen

    -   Refrigerator

    -   Dining table

    -   Dedicated workspace

    -   Elevator

    -   Microwave

    -   Dishes and silverware

    -   TV

    -   Pool

    -   Gym

    -   Pets allowed

```{r}
#| echo: false

### Keeping only variables that we are going to use.
Data_Mar = Data_Mar %>% 
  select(price, host_response_time, host_response_rate, host_acceptance_rate, host_is_superhost, host_total_listings_count, host_identity_verified, neighbourhood_cleansed, property_type, room_type, accommodates, bathrooms_text, amenities, minimum_nights, maximum_nights, has_availability, availability_30, availability_60, availability_90, availability_365, number_of_reviews, number_of_reviews_ltm, last_review, last_scraped,review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value, instant_bookable, description, neighborhood_overview)

Data_Sept = Data_Sept %>% 
  select(price, host_response_time, host_response_rate, host_acceptance_rate, host_is_superhost, host_total_listings_count, host_identity_verified, neighbourhood_cleansed, property_type, room_type, accommodates, bathrooms_text, amenities, minimum_nights, maximum_nights, has_availability, availability_30, availability_60, availability_90, availability_365, number_of_reviews, number_of_reviews_ltm, last_review, last_scraped, review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value, instant_bookable, description, neighborhood_overview)
```

```{r}
#| echo: false

### Converting the price to numeric 
Data_Mar$price <- gsub("\\$", "", Data_Mar$price)
Data_Mar$price <- as.numeric(gsub(",", "", Data_Mar$price))

Data_Sept$price <- gsub("\\$", "", Data_Sept$price)
Data_Sept$price <- as.numeric(gsub(",", "", Data_Sept$price))
```

```{r}
#| echo: false

## Let's tranform bathrooms_text.
Data_Mar %>% 
  count(bathrooms_text)

## It seems that we have 3 main categories
# 1. baths 2. shared baths 3.private baths 4. Half-bath
# Recode it in terms of number of baths (each category)
```

```{r}
#| echo: false

### Extracting number and types of bathrooms
## Start with March
# Initialize new columns
Data_Mar$num_baths <- numeric(nrow(Data_Mar))
Data_Mar$num_shared_baths <- numeric(nrow(Data_Mar))
Data_Mar$num_private_baths <- numeric(nrow(Data_Mar))
Data_Mar$is_half_bath <- numeric(nrow(Data_Mar))

# Extract information using regular expressions
for (i in seq_along(Data_Mar$bathrooms_text)) {
  # Check for NA
  if (!is.na(Data_Mar$bathrooms_text[i])) {
    # Extract number and type of bath
    match <- regmatches(Data_Mar$bathrooms_text[i], regexec("(\\d+)\\s*(shared|private)?\\s*baths?", Data_Mar$bathrooms_text[i]))[[1]]
    
    # Extract number
    num <- as.numeric(match[2])
    
    # Determine type and assign to corresponding variable
    if (grepl("shared", match[3], ignore.case = TRUE)) {
      Data_Mar$num_shared_baths[i] <- num
    } else if (grepl("private", match[3], ignore.case = TRUE)) {
      Data_Mar$num_private_baths[i] <- num
    } else {
      Data_Mar$num_baths[i] <- num
    }
    
    # Check if it is a half bath
    Data_Mar$is_half_bath[i] <- ifelse(grepl("half", tolower(Data_Mar$bathrooms_text[i])) || grepl("shared half", tolower(Data_Mar$bathrooms_text[i])), 1, 0)
  }
}

# Set values to NA if bathrooms_text is NA
Data_Mar$num_baths[is.na(Data_Mar$bathrooms_text)] <- NA
Data_Mar$num_shared_baths[is.na(Data_Mar$bathrooms_text)] <- NA
Data_Mar$num_private_baths[is.na(Data_Mar$bathrooms_text)] <- NA
Data_Mar$is_half_bath[is.na(Data_Mar$bathrooms_text)] <- NA


## Do the same thing for September
# Initialize new columns
Data_Sept$num_baths <- numeric(nrow(Data_Sept))
Data_Sept$num_shared_baths <- numeric(nrow(Data_Sept))
Data_Sept$num_private_baths <- numeric(nrow(Data_Sept))
Data_Sept$is_half_bath <- numeric(nrow(Data_Sept))

# Extract information using regular expressions
for (i in seq_along(Data_Sept$bathrooms_text)) {
  # Check for NA
  if (!is.na(Data_Sept$bathrooms_text[i])) {
    # Extract number and type of bath
    match <- regmatches(Data_Sept$bathrooms_text[i], regexec("(\\d+)\\s*(shared|private)?\\s*baths?", Data_Sept$bathrooms_text[i]))[[1]]
    
    # Extract number
    num <- as.numeric(match[2])
    
    # Determine type and assign to corresponding variable
    if (grepl("shared", match[3], ignore.case = TRUE)) {
      Data_Sept$num_shared_baths[i] <- num
    } else if (grepl("private", match[3], ignore.case = TRUE)) {
      Data_Sept$num_private_baths[i] <- num
    } else {
      Data_Sept$num_baths[i] <- num
    }
    
    # Check if it is a half bath
    Data_Sept$is_half_bath[i] <- ifelse(grepl("half", tolower(Data_Sept$bathrooms_text[i])) || grepl("shared half", tolower(Data_Sept$bathrooms_text[i])), 1, 0)
  }
}

# Set values to NA if bathrooms_text is NA
Data_Sept$num_baths[is.na(Data_Sept$bathrooms_text)] <- NA
Data_Sept$num_shared_baths[is.na(Data_Sept$bathrooms_text)] <- NA
Data_Sept$num_private_baths[is.na(Data_Sept$bathrooms_text)] <- NA
Data_Sept$is_half_bath[is.na(Data_Sept$bathrooms_text)] <- NA


# Drop the original 'bathrooms_text' column
Data_Mar <- subset(Data_Mar, select = -bathrooms_text)
Data_Sept <- subset(Data_Sept, select = -bathrooms_text)

```

```{r}
#| echo: false

### Extracing amenities into dummy variables
# List of amenities
amenities_list <- c("Hair dryer", "Shampoo", "Shower gel", "Air conditioning", "Essentials", 
                    "Wifi", "Washer", "Iron", "Smoking allowed", "Free parking on premises", 
                    "Luggage dropoff allowed", "Kitchen", "Refrigerator", "Dining table", 
                    "Dedicated workspace", "Elevator", "Microwave", "Dishes and silverware", 
                    "TV", "Pool", "Gym", "Pets allowed")

# Loop through the list and create dummy variables
for (amenity in amenities_list) {
  dummy_variable_name <- paste0(gsub(" ", "_", amenity), "_dummy")
  Data_Mar[[dummy_variable_name]] <- ifelse(sapply(Data_Mar$amenities, grepl, pattern = amenity), 1, 0)
}


for (amenity in amenities_list) {
  dummy_variable_name <- paste0(gsub(" ", "_", amenity), "_dummy")
  Data_Sept[[dummy_variable_name]] <- ifelse(sapply(Data_Sept$amenities, grepl, pattern = amenity), 1, 0)
}

# Drop the original 'amenities' column
Data_Mar <- subset(Data_Mar, select = -amenities)
Data_Sept <- subset(Data_Sept, select = -amenities)
```

\

```{r}
#| echo: false

### Encoding other variables into dummy variables
## host_response_time
Data_Mar = dummy_cols(Data_Mar, select_columns = "host_response_time", remove_first_dummy = TRUE, remove_selected_columns = TRUE)

Data_Sept = dummy_cols(Data_Sept, select_columns = "host_response_time", remove_first_dummy = TRUE, remove_selected_columns = TRUE)

## neighbourhood_cleansed
Data_Mar = dummy_cols(Data_Mar, select_columns = "neighbourhood_cleansed", remove_first_dummy = TRUE, remove_selected_columns = TRUE)

Data_Sept = dummy_cols(Data_Sept, select_columns = "neighbourhood_cleansed", remove_first_dummy = TRUE, remove_selected_columns = TRUE)


## property_type
Data_Mar = dummy_cols(Data_Mar, select_columns = "property_type", remove_first_dummy = TRUE, remove_selected_columns = TRUE)

Data_Sept = dummy_cols(Data_Sept, select_columns = "property_type", remove_first_dummy = TRUE, remove_selected_columns = TRUE)

## room_type
Data_Mar = dummy_cols(Data_Mar, select_columns = "room_type", remove_first_dummy = TRUE, remove_selected_columns = TRUE)

Data_Sept = dummy_cols(Data_Sept, select_columns = "room_type", remove_first_dummy = TRUE, remove_selected_columns = TRUE)

```

```{r}
#| echo: false

### Creating variable called "time_since_last_review"
# Convert data to date first

Data_Mar$last_review <- as.Date(Data_Mar$last_review, "%Y-%b-%d")

Data_Mar$last_scraped <- as.Date(Data_Mar$last_scraped, "%Y-%b-%d")

Data_Sept$last_review <- as.Date(Data_Sept$last_review, "%Y-%b-%d")

Data_Sept$last_scraped <- as.Date(Data_Sept$last_scraped, "%Y-%b-%d")

# Calculate the time between the two dates

Data_Mar$time_since_last_review <- Data_Mar$last_scraped - Data_Mar$last_review

Data_Sept$time_since_last_review <- Data_Sept$last_scraped - Data_Sept$last_review

# Removing the used two columns
Data_Mar = Data_Mar %>%
  select(-c(last_review, last_scraped))

Data_Sept = Data_Sept %>%
  select(-c(last_review, last_scraped))

```

```{r}
#| echo: false
### Extrating Information about Skytrain, Metro
## MRT (Subway)

# Define a vector of keywords related to public transport
MRT_keywords <- c("\\bMRT\\b", "\\bmrt\\b", "\\bMetro\\b", "\\bmetro\\b", "\\bSubway\\b", "\\bsubway\\b")

# Use the keywords in grepl and create a new column
Data_Mar$near_MRT <- ifelse(
  grepl(paste(MRT_keywords, collapse = "|"), 
        Data_Mar$description, ignore.case = TRUE) |
  grepl(paste(MRT_keywords, collapse = "|"), 
        Data_Mar$neighborhood_overview, ignore.case = TRUE),
  1, 0
)

## BTS (Skytrain)
BTS_keywords <- c("\\bBTS\\b", "\\bbts\\b", "\\bSkytrain\\b", "\\bskytrain\\b")

Data_Mar$near_BTS <- ifelse(
  grepl(paste(BTS_keywords, collapse = "|"), 
        Data_Mar$description, ignore.case = TRUE) |
  grepl(paste(BTS_keywords, collapse = "|"), 
        Data_Mar$neighborhood_overview, ignore.case = TRUE),
  1, 0
)


## ARL (Airport Rail Link)
ARL_keywords <- c("\\bAirport Rail Link\\b", "\\bAirport Link\\b", "\\bairport rail link\\b", "\\bairport link\\b", "\\bARL\\b", "\\barl\\b")

Data_Mar$near_ARL <- ifelse(
  grepl(paste(ARL_keywords, collapse = "|"), 
        Data_Mar$description, ignore.case = TRUE) |
  grepl(paste(ARL_keywords, collapse = "|"), 
        Data_Mar$neighborhood_overview, ignore.case = TRUE),
  1, 0
)

# Set values to NA if description and neighborhood_overview are NA

Data_Mar <- Data_Mar %>%
  mutate(near_MRT = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_MRT))

Data_Mar <- Data_Mar %>%
  mutate(near_BTS = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_BTS))

Data_Mar <- Data_Mar %>%
  mutate(near_ARL = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_ARL))

# Drop description and neighborhood_overview
Data_Mar = Data_Mar %>%
  select(-c(description, neighborhood_overview))


### Do the same thing for September.
Data_Sept$near_MRT <- ifelse(
  grepl(paste(MRT_keywords, collapse = "|"), 
        Data_Sept$description, ignore.case = TRUE) |
  grepl(paste(MRT_keywords, collapse = "|"), 
        Data_Sept$neighborhood_overview, ignore.case = TRUE),
  1, 0
)

Data_Sept$near_BTS <- ifelse(
  grepl(paste(BTS_keywords, collapse = "|"), 
        Data_Sept$description, ignore.case = TRUE) |
  grepl(paste(BTS_keywords, collapse = "|"), 
        Data_Sept$neighborhood_overview, ignore.case = TRUE),
  1, 0
)

Data_Sept$near_ARL <- ifelse(
  grepl(paste(ARL_keywords, collapse = "|"), 
        Data_Sept$description, ignore.case = TRUE) |
  grepl(paste(ARL_keywords, collapse = "|"), 
        Data_Sept$neighborhood_overview, ignore.case = TRUE),
  1, 0
)


Data_Sept <- Data_Sept %>%
  mutate(near_MRT = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_MRT))

Data_Sept <- Data_Sept %>%
  mutate(near_BTS = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_BTS))

Data_Sept <- Data_Sept %>%
  mutate(near_ARL = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_ARL))

Data_Sept = Data_Sept %>% select(-c(description, neighborhood_overview))

```


```{r}
## Examining NA values

Data_Mar %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "column", values_to = "na_count") %>%
  arrange(desc(na_count)) %>% kable()

```

```{r}
## Examining NA values again for Data_Sept
Data_Sept %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "column", values_to = "na_count") %>%
  arrange(desc(na_count)) %>% kable()
```


### Dealing with NAs 

-   For scores, replace it the mean and add binary flag variable to capture this.

-   For *time_since_last_review*, replace it with max(time_since_last_review). These are accommodations with no review yet. Prospect customers may see these place similar to those which did not get any review for a long time.

-  Those with *host_acceptance_rate* and *host_response_rate*  = NA are likely to be newcomers. We will drop these. 

-  For *near_MRT*, *near_BTS*, and *near_ARL*, replace NA with 0. 

- For *host_is_superhost*, replace NA with 0.

-  Those with missing values for the number of bathrooms can be dropped since there are only a few of them.

```{r}
## Drop those with missing values for host_acceptance_rate and host_response_rate

Data_Mar <- Data_Mar %>%
  filter(!is.na(host_acceptance_rate) & !is.na(host_response_rate))

Data_Sept <- Data_Sept %>% 
  filter(!is.na(host_acceptance_rate) & !is.na(host_response_rate))

## Drop those with missing values for baths
Data_Mar <- Data_Mar %>%
  filter(!is.na(num_baths) & !is.na(num_shared_baths) & !is.na(is_half_bath) & !is.na(num_private_baths))

Data_Sept <- Data_Sept %>% 
  filter(!is.na(num_baths) & !is.na(num_shared_baths) & !is.na(is_half_bath) & !is.na(num_private_baths))

```

```{r}
## Replace NA values in near_MRT, near_BTS, and near_ARL with 0

Data_Mar <- Data_Mar %>%
  mutate(across(c(near_MRT, near_BTS, near_ARL), ~ ifelse(is.na(.), 0, .)))

Data_Sept <- Data_Sept %>% 
  mutate(across(c(near_MRT, near_BTS, near_ARL), ~ ifelse(is.na(.), 0, .)))

## Replace NA values in host_is_superhost with 0
Data_Mar <- Data_Mar %>%
  mutate(host_is_superhost = ifelse(is.na(host_is_superhost), 0, host_is_superhost))

Data_Sept <- Data_Sept %>% 
  mutate(host_is_superhost = ifelse(is.na(host_is_superhost), 0, host_is_superhost))

```


```{r}
## Replace NA values in time_since_last_review with max
Data_Mar <- Data_Mar %>%
  mutate(time_since_last_review = ifelse(is.na(time_since_last_review), max(time_since_last_review, na.rm = TRUE), time_since_last_review))

Data_Sept <- Data_Sept %>% 
  mutate(time_since_last_review = ifelse(is.na(time_since_last_review), max(time_since_last_review, na.rm = TRUE), time_since_last_review))
```


```{r}
## Replace NA values in scores with mean
Data_Mar <- Data_Mar %>%
  mutate(across(c(review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))

Data_Sept <- Data_Sept %>% 
  mutate(across(c(review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))

# Create a binary flag variable to capture the imputation
Data_Mar <- Data_Mar %>%
  mutate(review_scores_rating_imputed = ifelse(is.na(review_scores_rating), 1, 0))

Data_Sept <- Data_Sept %>% 
  mutate(review_scores_rating_imputed = ifelse(is.na(review_scores_rating), 1, 0))

```

```{r}
## Examining NA values again
Data_Mar %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "column", values_to = "na_count") %>%
  arrange(desc(na_count)) %>% kable()

```

## Bulidng Models
I will consider three main types of models: linear regression, random forest, and boosting. The details of each model will be discussed in the following sections.


### Linear Regression
I consider 5 linear regression models. The one that will be selected to compared with other two models is the one with the lowest RMSE. 

The five models are:
1. Model 1: Only variables related to reviews except the *time_since_last_review* 
2. Model 2: Model 1 + characteristics of the living space
3. Model 3: Model 2 + information about location
4. Model 4: Model 3 + information about the host 
5. Model 5: All variables

Model 1: *price* = *f*(*review_scores_rating*, *review_scores_accuracy*, *review_scores_cleanliness*, *review_scores_checkin*, *review_scores_communication*, *review_scores_location*, *review_scores_value*, *review_scores_rating_imputed*)

Model 2: *price* = model 1 + *accommodates*, *bedrooms*, *beds*, *property_type*, *room_type*, *num_baths*, *num_shared_baths*, *is_half_bath*, *num_private_baths*, *amenities*

Model 3: *price* = model 2 + *near_MRT*, *near_BTS*, *near_ARL*, *neighborhood*

Model 4: *price* = model 3 + *host_is_superhost*, *host_response_time*, *host_response_rate*, *host_acceptance_rate*, *host_total_listings_count*, *host_identity_verified*

Model 5: *price* = *f*(all variables)

#### Selecting the best OLs model
```{r}

```{r}
