---
title: "Assignment 2 - AirBnB"
author: "Phakphum Jatupitpornchan"
format: html
editor: visual
---

```{r}
#| echo: false
#| warning: false

rm(list=ls())

library(readr)
library(dplyr)
library(ggplot2)
library(weights)
library(caret)
library(kableExtra)
library(tidyr)
library(fastDummies)
library(data.table)
library(car)

# Set Working Directory and Importing Data

setwd("D:/Onedrive-CEU/OneDrive - Central European University/CEU/Prediction with Machine Learning/Assignment/DA3-phdma/Assignment 2")

Data_Mar <- read_csv("listings_mar_2023.csv", show_col_types = FALSE, na = c("", "NA", "N/A"))
```

# Task 1
## Defining Live Data and Sample

Live data: Observations with *property_type*%in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment") & *accommodates* \>= 2 & *accommodates* \<= 6

Sample: Observations with *property_type* %in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment", "Entire home/apt", "Entire condo", "Private room in condo", "Shared room in condo") & *accommodates* \>= 2 & *accommodates* \<= 6.

The definition of sample here (apartments and condos) is wider than the definition of target observations (apartments) to increase the sample size.

I split the sample into 2 main parts.

1.  Hold-out set: 15% of apartments randomly selected to be in the hold-out set. I only use apartments because the results on performance in this case would then be closer to the results from actual live data which only contains apartments.
2.  Work set: The remaining 85% of the sample is the work set. It is split further to be training set and test set.

```{r}
### Split sample into hold-out and work set.
set.seed(20231126)

## hold-out set will only consists of apartments. Split 20% of apartments into hold-out set.
hold_out_Mar <- Data_Mar %>%
  filter(property_type %in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment")) %>%
  sample_frac(0.20)

## Subtract hold-out set from the sample to get work set.
Data_Mar <- Data_Mar %>%
  filter(!id %in% hold_out_Mar$id)

## Deleting id column
hold_out_Mar <- hold_out_Mar %>%
  select(-id)

Data_Mar <- Data_Mar %>%
  select(-id)

```

```{r}
#| echo: false

### Filtering data
Data_Mar = Data_Mar %>% 
  filter(property_type %in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment", "Entire home/apt", "Entire condo", "Private room in condo", "Shared room in condo"), accommodates >= 2, accommodates <= 6)
```

## Features Engineering

### Picking features

-   Information about host

    -   Host response time (*host_response_time*)

    -   Host response rate (*host_response_rate*)

    -   Host acceptance rate (*host_acceptance_rate*)

    -   Is superhost (*host_is_superhost*)

    -   Total listings (*host_total_listings_count*)

    -   Has identity identified (*host_identity_verified*)

-   Information about the accomodation

    -   Neighbourhood (*neighbourhood_cleansed*)

    -   Types of property (*property_type*)

    -   Types of room (*room_type*)

    -   Number of people that can be accommodated (*accommodates*)

    -   Types and number of bathrooms (*bathrooms_text*)

    -   Number of bedrooms (*bedrooms*)

    -   Number of beds (*beds*)

    -   Amenities (*amenities*)

    -   Minimum number of night stay for the listing (*minimum_nights*)

    -   Maximum number of night stay for the listing (*maximum_nights*)

    -   Is availability (*has_availability*)

    -   The availability of the listing 30 days in the future as determined by the calendar (*availability_30*)

    -   The availability of the listing 60 days in the future as determined by the calendar (*availability_60*)

    -   The availability of the listing 90 days in the future as determined by the calendar (*availability_90*)

    -   The availability of the listing 365 days in the future as determined by the calendar (*availability_365*)

    -   The number of reviews the listing has (*number_of_reviews*)

    -   The number of reviews the listing has (in the last 12 months) (*number_of_reviews_ltm*)

    -   The date of the last/newest review (*last_review*)

    -   Overall review rating (review_scores_rating)

    -   Average accuracy review rating (*review_scores_accuracy*)

    -   Average cleanliness review rating (*review_scores_cleanliness*)

    -   Average check-in review rating (*review_scores_checkin*)

    -   Average communication review rating (*review_scores_communication*)

    -   Average location review rating (*review_scores_location*)

    -   Average value review rating (*review_scores_value*)

    -   Whether the guest can automatically book the listing without the host requiring to accept their booking request. (*instant_bookable*)

    -   Description of the accommodation (*description*)

    -   Description of the neighborhood (*neighborhood_overview*)

        -   BTS, bts, Skytrain, skytrain, MRT, mrt, Metro, metro, Subway, subway, Airport Rail Link, Airport Link, airport rail link, airport link, ARL, arl

-   Only use the most relevant amenities, otherwise takes too long.

    -   Hair dryer

    -   Shampoo

    -   Shower gel

    -   Air conditioning

    -   Essentials

    -   Wifi

    -   Washer

    -   Iron

    -   Smoking allowed

    -   Free parking on premises

    -   Luggage dropoff allowed

    -   Kitchen

    -   Refrigerator

    -   Dining table

    -   Dedicated workspace

    -   Elevator

    -   Microwave

    -   Dishes and silverware

    -   TV

    -   Pool

    -   Gym

    -   Pets allowed

```{r}
#| echo: false

### Keeping only variables that we are going to use.
Data_Mar = Data_Mar %>% 
  select(price, host_response_time, host_response_rate, host_acceptance_rate, host_is_superhost, host_total_listings_count, host_identity_verified, neighbourhood_cleansed, property_type, room_type, accommodates, bathrooms_text, bedrooms, beds, amenities, minimum_nights, maximum_nights, has_availability, availability_30, availability_60, availability_90, availability_365, number_of_reviews, number_of_reviews_ltm, last_review, last_scraped,review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value, instant_bookable, description, neighborhood_overview)
```

```{r}
#| echo: false

### Converting the price to numeric 
Data_Mar$price <- gsub("\\$", "", Data_Mar$price)
Data_Mar$price <- as.numeric(gsub(",", "", Data_Mar$price))

```

```{r}
#| echo: false

## Converting host_response_rate to numeric
Data_Mar$host_response_rate <- gsub("\\%", "", Data_Mar$host_response_rate)

Data_Mar$host_response_rate <- as.numeric(gsub(",", "", Data_Mar$host_response_rate))

## Converting host_acceptance_rate to numeric
Data_Mar$host_acceptance_rate <- gsub("\\%", "", Data_Mar$host_acceptance_rate)

Data_Mar$host_acceptance_rate <- as.numeric(gsub(",", "", Data_Mar$host_acceptance_rate))

```

```{r}
#| echo: false

## Let's tranform bathrooms_text.
Data_Mar %>% 
  count(bathrooms_text)

## It seems that we have 3 main categories
# 1. baths 2. shared baths 3.private baths 4. Half-bath
# Recode it in terms of number of baths (each category)
```

```{r}
#| echo: false

### Extracting number and types of bathrooms
## Start with March
# Initialize new columns
Data_Mar$num_baths <- numeric(nrow(Data_Mar))
Data_Mar$num_shared_baths <- numeric(nrow(Data_Mar))
Data_Mar$num_private_baths <- numeric(nrow(Data_Mar))
Data_Mar$is_half_bath <- numeric(nrow(Data_Mar))

# Extract information using regular expressions
for (i in seq_along(Data_Mar$bathrooms_text)) {
  # Check for NA
  if (!is.na(Data_Mar$bathrooms_text[i])) {
    # Extract number and type of bath
    match <- regmatches(Data_Mar$bathrooms_text[i], regexec("(\\d+)\\s*(shared|private)?\\s*baths?", Data_Mar$bathrooms_text[i]))[[1]]
    
    # Extract number
    num <- as.numeric(match[2])
    
    # Determine type and assign to corresponding variable
    if (grepl("shared", match[3], ignore.case = TRUE)) {
      Data_Mar$num_shared_baths[i] <- num
    } else if (grepl("private", match[3], ignore.case = TRUE)) {
      Data_Mar$num_private_baths[i] <- num
    } else {
      Data_Mar$num_baths[i] <- num
    }
    
    # Check if it is a half bath
    Data_Mar$is_half_bath[i] <- ifelse(grepl("half", tolower(Data_Mar$bathrooms_text[i])) || grepl("shared half", tolower(Data_Mar$bathrooms_text[i])), 1, 0)
  }
}

# Set values to NA if bathrooms_text is NA
Data_Mar$num_baths[is.na(Data_Mar$bathrooms_text)] <- NA
Data_Mar$num_shared_baths[is.na(Data_Mar$bathrooms_text)] <- NA
Data_Mar$num_private_baths[is.na(Data_Mar$bathrooms_text)] <- NA
Data_Mar$is_half_bath[is.na(Data_Mar$bathrooms_text)] <- NA


# Drop the original 'bathrooms_text' column
Data_Mar <- subset(Data_Mar, select = -bathrooms_text)


```

```{r}
#| echo: false

### Extracting amenities into dummy variables
# List of amenities
amenities_list <- c("Hair dryer", "Shampoo", "Shower gel", "Air conditioning", "Essentials", 
                    "Wifi", "Washer", "Iron", "Smoking allowed", "Free parking on premises", 
                    "Luggage dropoff allowed", "Kitchen", "Refrigerator", "Dining table", 
                    "Dedicated workspace", "Elevator", "Microwave", "Dishes and silverware", 
                    "TV", "Pool", "Gym", "Pets allowed")

# Loop through the list and create dummy variables
for (amenity in amenities_list) {
  dummy_variable_name <- paste0(gsub(" ", "_", amenity), "_dummy")
  Data_Mar[[dummy_variable_name]] <- ifelse(sapply(Data_Mar$amenities, grepl, pattern = amenity), 1, 0)
}


# Drop the original 'amenities' column
Data_Mar <- subset(Data_Mar, select = -amenities)


```

\

```{r}
#| echo: false

### Encoding other variables into dummy variables
## host_response_time
Data_Mar = dummy_cols(Data_Mar, select_columns = "host_response_time", remove_first_dummy = TRUE, remove_selected_columns = TRUE)



# drop host_response_time_NA
Data_Mar <- subset(Data_Mar, select = -host_response_time_NA)


## neighbourhood_cleansed
Data_Mar = dummy_cols(Data_Mar, select_columns = "neighbourhood_cleansed", remove_first_dummy = TRUE, remove_selected_columns = TRUE)

## property_type
Data_Mar = dummy_cols(Data_Mar, select_columns = "property_type", remove_first_dummy = TRUE, remove_selected_columns = TRUE)


## room_type
Data_Mar = dummy_cols(Data_Mar, select_columns = "room_type", remove_first_dummy = TRUE, remove_selected_columns = TRUE)


```

```{r}
#| echo: false

### Creating variable called "time_since_last_review"
# Convert data to date first

Data_Mar$last_review <- as.Date(Data_Mar$last_review, "%Y-%b-%d")

Data_Mar$last_scraped <- as.Date(Data_Mar$last_scraped, "%Y-%b-%d")


# Calculate the time between the two dates

Data_Mar$time_since_last_review <- Data_Mar$last_scraped - Data_Mar$last_review


# Removing the used two columns
Data_Mar = Data_Mar %>%
  select(-c(last_review, last_scraped))


```

```{r}
#| echo: false
### Extrating Information about Skytrain, Metro
## MRT (Subway)

# Define a vector of keywords related to public transport
MRT_keywords <- c("\\bMRT\\b", "\\bmrt\\b", "\\bMetro\\b", "\\bmetro\\b", "\\bSubway\\b", "\\bsubway\\b")

# Use the keywords in grepl and create a new column
Data_Mar$near_MRT <- ifelse(
  grepl(paste(MRT_keywords, collapse = "|"), 
        Data_Mar$description, ignore.case = TRUE) |
  grepl(paste(MRT_keywords, collapse = "|"), 
        Data_Mar$neighborhood_overview, ignore.case = TRUE),
  1, 0
)

## BTS (Skytrain)
BTS_keywords <- c("\\bBTS\\b", "\\bbts\\b", "\\bSkytrain\\b", "\\bskytrain\\b")

Data_Mar$near_BTS <- ifelse(
  grepl(paste(BTS_keywords, collapse = "|"), 
        Data_Mar$description, ignore.case = TRUE) |
  grepl(paste(BTS_keywords, collapse = "|"), 
        Data_Mar$neighborhood_overview, ignore.case = TRUE),
  1, 0
)


## ARL (Airport Rail Link)
ARL_keywords <- c("\\bAirport Rail Link\\b", "\\bAirport Link\\b", "\\bairport rail link\\b", "\\bairport link\\b", "\\bARL\\b", "\\barl\\b")

Data_Mar$near_ARL <- ifelse(
  grepl(paste(ARL_keywords, collapse = "|"), 
        Data_Mar$description, ignore.case = TRUE) |
  grepl(paste(ARL_keywords, collapse = "|"), 
        Data_Mar$neighborhood_overview, ignore.case = TRUE),
  1, 0
)

# Set values to NA if description and neighborhood_overview are NA

Data_Mar <- Data_Mar %>%
  mutate(near_MRT = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_MRT))

Data_Mar <- Data_Mar %>%
  mutate(near_BTS = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_BTS))

Data_Mar <- Data_Mar %>%
  mutate(near_ARL = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_ARL))

# Drop description and neighborhood_overview
Data_Mar = Data_Mar %>%
  select(-c(description, neighborhood_overview))


```

```{r}
## Examining NA values

Data_Mar %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "column", values_to = "na_count") %>%
  arrange(desc(na_count)) %>% kable()

```

```{r}
## Examining NA values again for the holdout set

hold_out_Mar %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "column", values_to = "na_count") %>%
  arrange(desc(na_count)) %>% kable()

```

```{r}
```

### Dealing with NAs

-   For scores, replace it with the mean and add binary flag variable to capture this.

-   For *time_since_last_review*, replace it with max(time_since_last_review). These are accommodations with no review yet. Prospect customers may see these place similar to those which did not get any review for a long time.

-   Those with *host_acceptance_rate* and *host_response_rate* = NA are likely to be newcomers. We will drop these.

-   For *near_MRT*, *near_BTS*, and *near_ARL*, replace NA with 0.

-   For *host_is_superhost*, replace NA with 0.

-   For *bedrooms* and *beds*, replace NA with the mean and add binary flag variable to capture this.

-   Those with missing values for the number of bathrooms can be dropped since there are only a few of them.

```{r}
## Drop those with missing values for host_acceptance_rate and host_response_rate

Data_Mar <- Data_Mar %>%
  filter(!is.na(host_acceptance_rate) & !is.na(host_response_rate))


## Drop those with missing values for baths
Data_Mar <- Data_Mar %>%
  filter(!is.na(num_baths) & !is.na(num_shared_baths) & !is.na(is_half_bath) & !is.na(num_private_baths))


```

```{r}
## Replace NA values in near_MRT, near_BTS, and near_ARL with 0

Data_Mar <- Data_Mar %>%
  mutate(across(c(near_MRT, near_BTS, near_ARL), ~ ifelse(is.na(.), 0, .)))



## Replace NA values in host_is_superhost with 0
Data_Mar <- Data_Mar %>%
  mutate(host_is_superhost = ifelse(is.na(host_is_superhost), 0, host_is_superhost))


```

```{r}
## Replace NA values in time_since_last_review with max
Data_Mar <- Data_Mar %>%
  mutate(time_since_last_review = ifelse(is.na(time_since_last_review), max(time_since_last_review, na.rm = TRUE), time_since_last_review))

```

```{r}
## Replace NA values in scores with mean
Data_Mar <- Data_Mar %>%
  mutate(across(c(review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))


# Create a binary flag variable to capture the imputation
Data_Mar <- Data_Mar %>%
  mutate(review_scores_rating_imputed = ifelse(is.na(review_scores_rating), 1, 0))

## Replace NA values in bedrooms and beds with mean
Data_Mar <- Data_Mar %>%
  mutate(across(c(bedrooms, beds), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))


# Create a binary flag variable to capture the imputation
Data_Mar <- Data_Mar %>%
  mutate(bedrooms_imputed = ifelse(is.na(bedrooms), 1, 0))



```

## Building Models

I will consider three main types of models: linear regression, random forest, and bagging. Linear regression offers high interpretability, random forest offers high-quality prediction. Bagging is chosen to demonstrate the gain from decorrelating the trees.

The details of each model will be discussed in the following sections.

### Linear Regression

I consider 6 linear regression models. The one that will be selected to compared with other two models is the one with the lowest RMSE.

The five models are: 1. Model 1: Only variables related to reviews except the *time_since_last_review* 2. Model 2: Model 1 + characteristics of the living space 3. Model 3: Model 2 + information about rail transportation 4. Model 4: Model 3 + information about the neighborhood 5. Model 5: Model 4 + information about the host 6. Model 6: All variables

Model 1: *price* = *f*(*review_scores_rating*, *review_scores_accuracy*, *review_scores_cleanliness*, *review_scores_checkin*, *review_scores_communication*, *review_scores_location*, *review_scores_value*, *review_scores_rating_imputed*)

Model 2: *price* = model 1 + *accommodates*, *bedrooms*, *beds*, *property_type*, *room_type*, *num_baths*, *num_shared_baths*, *is_half_bath*, *num_private_baths*, *amenities*

Model 3: *price* = model 2 + *near_MRT*, *near_BTS*, *near_ARL*,

Model 4: *price* = model 3 + *neighborhood*

Model 5: *price* = model 4 + *host_is_superhost*, *host_response_time*, *host_response_rate*, *host_acceptance_rate*, *host_total_listings_count*, *host_identity_verified*

Model 6: *price* = *f*(all variables)

#### Selecting the best OLS model

```{r}
#| Echo = FALSE
#| Warning = FALSE

#### Selecting by using 5-fold cross validation
set.seed(20231126)
# Getting the indices for 5-fold cross validation
folds <- createFolds(Data_Mar$price, k = 5, list = TRUE, returnTrain = TRUE)

### Estimating Models and obtains RMSE (5-folds CV)
## Model 1
results <- list()

for (i in 1:5) {
  # Get the training and test data
  train <- Data_Mar[folds[[i]], ]
  test <- Data_Mar[-folds[[i]], ]
  
  # Estimate the model
  model_OLS_1 <- lm(price ~ review_scores_rating + review_scores_accuracy + review_scores_cleanliness + review_scores_checkin + review_scores_communication + review_scores_location + review_scores_value + review_scores_rating_imputed, data = train)
  
  # Predict the test data
  test$pred <- predict(model_OLS_1, newdata = test)
  
  # Calculate the RMSE
  rmse <- RMSE(test$pred, test$price)
  
  # Store the results
  results[[i]] <- rmse
}
 
# Calculate the average RMSE
RMSE_OLS_1 <- sqrt(mean(unlist(results)^2))

## Model 2
results <- list()

for (i in 1:5) {
  # Get the training and test data
  train <- Data_Mar[folds[[i]], ]
  test <- Data_Mar[-folds[[i]], ]
  
  # Estimate the model
  model_OLS_2 <- update(model_OLS_1, . ~ . + accommodates + bedrooms + beds + num_baths + num_shared_baths + is_half_bath + num_private_baths + Hair_dryer_dummy + Shampoo_dummy + TV_dummy + Wifi_dummy + Shower_gel_dummy + Air_conditioning_dummy + Kitchen_dummy + Elevator_dummy + Free_parking_on_premises_dummy + Gym_dummy + Pool_dummy + Washer_dummy + Essentials_dummy + Iron_dummy + Smoking_allowed_dummy + Luggage_dropoff_allowed_dummy + Refrigerator_dummy + Dining_table_dummy + Dedicated_workspace_dummy + Microwave_dummy + Dishes_and_silverware_dummy + Pets_allowed_dummy + `property_type_Entire home/apt` + `property_type_Entire serviced apartment` + `property_type_Private room in condo` + `property_type_Private room in serviced apartment` + `property_type_Room in serviced apartment` + `property_type_Shared room in serviced apartment` + `property_type_Shared room in condo` + `room_type_Hotel room` + `room_type_Private room` + `room_type_Shared room`, data = train)
  
  # Predict the test data
  test$pred <- predict(model_OLS_2, newdata = test)
  
  # Calculate the RMSE
  rmse <- RMSE(test$pred, test$price)
  
  # Store the results
  results[[i]] <- rmse
}

# Calculate the average RMSE
RMSE_OLS_2 <- sqrt(mean(unlist(results)^2))


## Model 3
results <- list()

for (i in 1:5) {
  # Get the training and test data
  train <- Data_Mar[folds[[i]], ]
  test <- Data_Mar[-folds[[i]], ]
  
  # Estimate the model
  model_OLS_3 <- update(model_OLS_2, . ~ . + near_MRT + near_BTS + near_ARL, data = train)
  
  # Predict the test data
  test$pred <- predict(model_OLS_3, newdata = test)
  
  # Calculate the RMSE
  rmse <- RMSE(test$pred, test$price)
  
  # Store the results
  results[[i]] <- rmse
}

# Calculate the average RMSE
RMSE_OLS_3 <- sqrt(mean(unlist(results)^2))


## Model 4
results <- list()

for (i in 1:5) {
  # Get the training and test data
  train <- Data_Mar[folds[[i]], ]
  test <- Data_Mar[-folds[[i]], ]
  
  # Estimate the model
  model_OLS_4 <- update(model_OLS_3, . ~ . + `neighbourhood_cleansed_Bang Kapi` + `neighbourhood_cleansed_Bang Khae` + `neighbourhood_cleansed_Bang Khen` + `neighbourhood_cleansed_Bang Kho laen` + `neighbourhood_cleansed_Bang Khun thain` + `neighbourhood_cleansed_Bang Na` + `neighbourhood_cleansed_Bang Phlat` + `neighbourhood_cleansed_Bang Rak` + `neighbourhood_cleansed_Bang Sue` + `neighbourhood_cleansed_Bangkok Noi` + `neighbourhood_cleansed_Bangkok Yai` + `neighbourhood_cleansed_Bueng Kum` + `neighbourhood_cleansed_Chatu Chak` + `neighbourhood_cleansed_Chom Thong` + `neighbourhood_cleansed_Din Daeng` + `neighbourhood_cleansed_Don Mueang` + `neighbourhood_cleansed_Dusit` + `neighbourhood_cleansed_Huai Khwang` + `neighbourhood_cleansed_Khan Na Yao` +  `neighbourhood_cleansed_Khlong San` + `neighbourhood_cleansed_Khlong Toei` + `neighbourhood_cleansed_Lak Si` + `neighbourhood_cleansed_Lat Krabang` + `neighbourhood_cleansed_Lat Phrao` + `neighbourhood_cleansed_Min Buri` + `neighbourhood_cleansed_Nong Chok` + `neighbourhood_cleansed_Nong Khaem` + `neighbourhood_cleansed_Phasi Charoen` +   `neighbourhood_cleansed_Ratchathewi` + `neighbourhood_cleansed_Sai Mai` + `neighbourhood_cleansed_Samphanthawong` + `neighbourhood_cleansed_Saphan Sung` + `neighbourhood_cleansed_Sathon` + `neighbourhood_cleansed_Taling Chan` +  `neighbourhood_cleansed_Thon buri` +  `neighbourhood_cleansed_Parthum Wan` + `neighbourhood_cleansed_Phaya Thai` + `neighbourhood_cleansed_Phra Khanong` + `neighbourhood_cleansed_Phra Nakhon` + `neighbourhood_cleansed_Pom Prap Sattru Phai` + `neighbourhood_cleansed_Pra Wet` + `neighbourhood_cleansed_Rat Burana` + `neighbourhood_cleansed_Ratchathewi` + `neighbourhood_cleansed_Sai Mai` + `neighbourhood_cleansed_Samphanthawong` + `neighbourhood_cleansed_Saphan Sung` + `neighbourhood_cleansed_Sathon` + `neighbourhood_cleansed_Suanluang` + `neighbourhood_cleansed_Thung khru` + `neighbourhood_cleansed_Vadhana` + `neighbourhood_cleansed_Wang Thong Lang` + `neighbourhood_cleansed_Yan na wa`, data = train)
  
  # Predict the test data
  test$pred <- predict(model_OLS_4, newdata = test)
  
  # Calculate the RMSE
  rmse <- RMSE(test$pred, test$price)
  
  # Store the results
  results[[i]] <- rmse
}

# Calculate the average RMSE
RMSE_OLS_4 <- sqrt(mean(unlist(results)^2))


## Model 5
results <- list()

for (i in 1:5) {
  # Get the training and test data
  train <- Data_Mar[folds[[i]], ]
  test <- Data_Mar[-folds[[i]], ]
  
  # Estimate the model
  model_OLS_5 <- update(model_OLS_4, . ~ . + host_is_superhost + host_response_rate + host_acceptance_rate + host_total_listings_count + host_identity_verified + `host_response_time_within a few hours` + `host_response_time_within an hour` + `host_response_time_within a day`, data = train)
  
  # Predict the test data
  test$pred <- predict(model_OLS_5, newdata = test)
  
  # Calculate the RMSE
  rmse <- RMSE(test$pred, test$price)
  
  # Store the results
  results[[i]] <- rmse
}

# Calculate the average RMSE
RMSE_OLS_5 <- sqrt(mean(unlist(results)^2))


## Model 6

results <- list()

for (i in 1:5) {
  # Get the training and test data
  train <- Data_Mar[folds[[i]], ]
  test <- Data_Mar[-folds[[i]], ]
  
  # Estimate the model
  model_OLS_6 <- lm(price ~ ., data = train)
  
  # Predict the test data
  test$pred <- predict(model_OLS_6, newdata = test)
  
  # Calculate the RMSE
  rmse <- RMSE(test$pred, test$price)
  
  # Store the results
  results[[i]] <- rmse
}

# Calculate the average RMSE
RMSE_OLS_6 <- sqrt(mean(unlist(results)^2))

```

```{r}
#| Echo = FALSE
## Put the results in a data frame
results <- data.frame(
  Model = c("OLS_1", "OLS_2", "OLS_3", "OLS_4", "OLS_5", "OLS_6"),
  RMSE = c(RMSE_OLS_1, RMSE_OLS_2, RMSE_OLS_3, RMSE_OLS_4, RMSE_OLS_5, RMSE_OLS_6)
)

# Print the table with borders
kable(results, digits = 2, align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "bordered"))
```

Model 3 is the best performing model with the lowest RMSE.

### Random Forest Model

Next, I consider the random forest model. 5-fold cross-validation is used to tune the parameters (*mtry*: Number of variables randomly sampled as candidates at each split, *ntree*: Number of trees, *nodesize*: Minimum size of terminal nodes)

```{r}
## Setting up the random forest
# specifying the range of values for the tuning parameters

mtry <- seq(20, 40, by = 1)

# Setting up the grid
grid <- expand.grid(mtry = mtry)

# setting up the control
control <- trainControl(method = "cv", number = 5)

# tuning the model
set.seed(20231126)

# I set ntree = 200 for the sake of computation time.
model_RF <- train(price ~ ., data = Data_Mar, method = "rf", trControl = control, tuneGrid = grid, ntree = 200)
```

```{r}
## Display the results of Random Forest.
model_RF
```


### Bagging Model



# Task 2
```{r}
### The live data is data from September 2023. 
## Import the data
Data_Sept <- read_csv("listings_sept_2023.csv", show_col_types = FALSE, na = c("", "NA", "N/A"))

## Repeat the same data cleaning process as in Task 1
Data_Sept = Data_Sept %>% 
  filter(property_type %in% c("Entire serviced apartment", "Private room in serviced apartment", "Room in serviced apartment", "Shared room in serviced apartment", "Entire home/apt", "Entire condo", "Private room in condo", "Shared room in condo"), accommodates >= 2, accommodates <= 6)

# Keep the columns that are used in the model
Data_Sept = Data_Sept %>% 
  select(price, host_response_time, host_response_rate, host_acceptance_rate, host_is_superhost, host_total_listings_count, host_identity_verified, neighbourhood_cleansed, property_type, room_type, accommodates, bathrooms_text, bedrooms, beds, amenities, minimum_nights, maximum_nights, has_availability, availability_30, availability_60, availability_90, availability_365, number_of_reviews, number_of_reviews_ltm, last_review, last_scraped, review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value, instant_bookable, description, neighborhood_overview)

# Convert the price column to numeric
Data_Sept$price <- gsub("\\$", "", Data_Sept$price)
Data_Sept$price <- as.numeric(gsub(",", "", Data_Sept$price))

# Convert the host_response_rate column to numeric
Data_Sept$host_response_rate <- gsub("\\%", "", Data_Sept$host_response_rate)

Data_Sept$host_response_rate <- as.numeric(gsub(",", "", Data_Sept$host_response_rate))

# Convert the host_acceptance_rate column to numeric
Data_Sept$host_acceptance_rate <- gsub("\\%", "", Data_Sept$host_acceptance_rate)

Data_Sept$host_acceptance_rate <- as.numeric(gsub(",", "", Data_Sept$host_acceptance_rate))

## Let's tranform bathrooms_text.
Data_Mar %>% 
  count(bathrooms_text)

# Initialize new columns
Data_Sept$num_baths <- numeric(nrow(Data_Sept))
Data_Sept$num_shared_baths <- numeric(nrow(Data_Sept))
Data_Sept$num_private_baths <- numeric(nrow(Data_Sept))
Data_Sept$is_half_bath <- numeric(nrow(Data_Sept))

# Extract information using regular expressions
for (i in seq_along(Data_Sept$bathrooms_text)) {
  # Check for NA
  if (!is.na(Data_Sept$bathrooms_text[i])) {
    # Extract number and type of bath
    match <- regmatches(Data_Sept$bathrooms_text[i], regexec("(\\d+)\\s*(shared|private)?\\s*baths?", Data_Sept$bathrooms_text[i]))[[1]]
    
    # Extract number
    num <- as.numeric(match[2])
    
    # Determine type and assign to corresponding variable
    if (grepl("shared", match[3], ignore.case = TRUE)) {
      Data_Sept$num_shared_baths[i] <- num
    } else if (grepl("private", match[3], ignore.case = TRUE)) {
      Data_Sept$num_private_baths[i] <- num
    } else {
      Data_Sept$num_baths[i] <- num
    }
    
    # Check if it is a half bath
    Data_Sept$is_half_bath[i] <- ifelse(grepl("half", tolower(Data_Sept$bathrooms_text[i])) || grepl("shared half", tolower(Data_Sept$bathrooms_text[i])), 1, 0)
  }
}

# Set values to NA if bathrooms_text is NA
Data_Sept$num_baths[is.na(Data_Sept$bathrooms_text)] <- NA
Data_Sept$num_shared_baths[is.na(Data_Sept$bathrooms_text)] <- NA
Data_Sept$num_private_baths[is.na(Data_Sept$bathrooms_text)] <- NA
Data_Sept$is_half_bath[is.na(Data_Sept$bathrooms_text)] <- NA

# Drop the original 'bathrooms_text' column
Data_Sept <- subset(Data_Sept, select = -bathrooms_text)

## Extracting amenities into dummy variables
for (amenity in amenities_list) {
  dummy_variable_name <- paste0(gsub(" ", "_", amenity), "_dummy")
  Data_Sept[[dummy_variable_name]] <- ifelse(sapply(Data_Sept$amenities, grepl, pattern = amenity), 1, 0)
}

# Drop the original 'amenities' column
Data_Sept <- subset(Data_Sept, select = -amenities)

## Encoding other variables into dummy variables
# host_response_time
Data_Sept = dummy_cols(Data_Sept, select_columns = "host_response_time", remove_first_dummy = TRUE, remove_selected_columns = TRUE)

# drop host_response_time_NA
Data_Sept <- subset(Data_Sept, select = -host_response_time_NA)

# neighbourhood_cleansed
Data_Sept = dummy_cols(Data_Sept, select_columns = "neighbourhood_cleansed", remove_first_dummy = TRUE, remove_selected_columns = TRUE)


# property_type
Data_Sept = dummy_cols(Data_Sept, select_columns = "property_type", remove_first_dummy = TRUE, remove_selected_columns = TRUE)

# room_type
Data_Sept = dummy_cols(Data_Sept, select_columns = "room_type", remove_first_dummy = TRUE, remove_selected_columns = TRUE)


## Creating variable called "time_since_last_review"
# Convert data to date first
Data_Sept$last_review <- as.Date(Data_Sept$last_review, "%Y-%b-%d")

Data_Sept$last_scraped <- as.Date(Data_Sept$last_scraped, "%Y-%b-%d")

# Calculate the time between the two dates
Data_Sept$time_since_last_review <- Data_Sept$last_scraped - Data_Sept$last_review

# Removing the used two columns
Data_Sept = Data_Sept %>%
  select(-c(last_review, last_scraped))


## Extrating Information about Skytrain, Metro
Data_Sept$near_MRT <- ifelse(
  grepl(paste(MRT_keywords, collapse = "|"), 
        Data_Sept$description, ignore.case = TRUE) |
  grepl(paste(MRT_keywords, collapse = "|"), 
        Data_Sept$neighborhood_overview, ignore.case = TRUE),
  1, 0
)

Data_Sept$near_BTS <- ifelse(
  grepl(paste(BTS_keywords, collapse = "|"), 
        Data_Sept$description, ignore.case = TRUE) |
  grepl(paste(BTS_keywords, collapse = "|"), 
        Data_Sept$neighborhood_overview, ignore.case = TRUE),
  1, 0
)

Data_Sept$near_ARL <- ifelse(
  grepl(paste(ARL_keywords, collapse = "|"), 
        Data_Sept$description, ignore.case = TRUE) |
  grepl(paste(ARL_keywords, collapse = "|"), 
        Data_Sept$neighborhood_overview, ignore.case = TRUE),
  1, 0
)


Data_Sept <- Data_Sept %>%
  mutate(near_MRT = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_MRT))

Data_Sept <- Data_Sept %>%
  mutate(near_BTS = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_BTS))

Data_Sept <- Data_Sept %>%
  mutate(near_ARL = ifelse(is.na(description) & is.na(neighborhood_overview), NA, near_ARL))

Data_Sept = Data_Sept %>% select(-c(description, neighborhood_overview))

## Dealing with NAs
# Drop those with missing values for host_acceptance_rate and host_response_rate
Data_Sept <- Data_Sept %>% 
  filter(!is.na(host_acceptance_rate) & !is.na(host_response_rate))

# Drop those with missing values for baths
Data_Sept <- Data_Sept %>% 
  filter(!is.na(num_baths) & !is.na(num_shared_baths) & !is.na(is_half_bath) & !is.na(num_private_baths))

# Replace NA values in near_MRT, near_BTS, and near_ARL with 0

Data_Sept <- Data_Sept %>% 
  mutate(across(c(near_MRT, near_BTS, near_ARL), ~ ifelse(is.na(.), 0, .)))

# Replace NA values in host_is_superhost with 0
Data_Sept <- Data_Sept %>% 
  mutate(host_is_superhost = ifelse(is.na(host_is_superhost), 0, host_is_superhost))

# Replace NA values in time_since_last_review with max
Data_Sept <- Data_Sept %>% 
  mutate(time_since_last_review = ifelse(is.na(time_since_last_review), max(time_since_last_review, na.rm = TRUE), time_since_last_review))

## Replace NA values in scores with mean
Data_Sept <- Data_Sept %>% 
  mutate(across(c(review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))

# Create a binary flag variable to capture the imputation
Data_Sept <- Data_Sept %>% 
  mutate(review_scores_rating_imputed = ifelse(is.na(review_scores_rating), 1, 0))

## Replace NA values in bedrooms and beds with mean
Data_Sept <- Data_Sept %>% 
  mutate(across(c(bedrooms, beds), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))

# Create a binary flag variable to capture the imputation
Data_Sept <- Data_Sept %>% 
  mutate(bedrooms_imputed = ifelse(is.na(bedrooms), 1, 0))


```

